#!/usr/bin/env node

/**
 * CLI for jest-swag
 */

import { program } from 'commander';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { OpenAPIGenerator } from './generator/openapi-generator';
import { apiSpecs, clearApiSpecs } from './utils';
import configLoader from './config/config-loader';

interface CLIOptions {
  title?: string;
  version?: string;
  description?: string;
  output?: string;
  server?: string[];
  config?: string;
  env?: string;
}

program
  .name('jest-swag')
  .description('Generate OpenAPI documentation from Jest API tests')
  .version('1.0.0');

program
  .command('generate')
  .description('Generate OpenAPI documentation')
  .option('-t, --title <title>', 'API title', 'API Documentation')
  .option('-v, --version <version>', 'API version', '1.0.0')
  .option('-d, --description <description>', 'API description')
  .option('-o, --output <path>', 'Output file path', './docs/openapi.json')
  .option(
    '-s, --server <url>',
    'Server URL (can be used multiple times)',
    collect,
    [],
  )
  .option('-c, --config <path>', 'Configuration file path')
  .option('-e, --env <environment>', 'Environment (development, staging, production)')
  .action(async (options: CLIOptions) => {
    try {
      // Load configuration from various sources
      const config = await configLoader.loadConfig({
        title: options.title,
        version: options.version,
        description: options.description,
        outputPath: options.output,
        servers: options.server?.map((url) => ({
          url,
          description: `Server: ${url}`,
        })),
      });

      // Set environment if specified
      if (options.env) {
        process.env.NODE_ENV = options.env;
      }

      // For CLI usage, we need to load specs from a temporary file
      // This would typically be saved by the Jest reporter
      const specsPath = getTempSpecsFilePath();
      if (fs.existsSync(specsPath)) {
        const savedSpecs = JSON.parse(fs.readFileSync(specsPath, 'utf8'));
        clearApiSpecs();
        savedSpecs.forEach((spec: any) => apiSpecs.push(spec));
      }

      if (apiSpecs.length === 0) {
        // Clean up temp file even if no specs
        cleanupTempFile(specsPath);
        return;
      }

      const generator = new OpenAPIGenerator({
        title: config.title || 'API Documentation',
        version: config.version || '1.0.0',
        description: config.description,
        servers: config.servers,
        outputPath: config.outputPath,
      });
      const document = await generator.generate();
      
      // Clean up temp file after generation
      cleanupTempFile(specsPath);
    } catch (error) {
      // Clean up temp file on error
      const specsPath = getTempSpecsFilePath();
      cleanupTempFile(specsPath);
      process.exit(1);
    }
  });

program
  .command('init')
  .description('Initialize jest-swag configuration in your project')
  .option('--example', 'Create example test file')
  .option('--force', 'Overwrite existing configuration')
  .action(async (options) => {
    try {
      const fs = require('fs');
      const path = require('path');
      const { execSync } = require('child_process');
      
      console.log('üöÄ Initializing jest-swag...\n');
      
      // Check if package.json exists
      const packageJsonPath = path.join(process.cwd(), 'package.json');
      if (!fs.existsSync(packageJsonPath)) {
        console.error('‚ùå No package.json found. Please run this command in your project root.');
        process.exit(1);
      }
      
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      
      // Detect project type
      const isNestJS = packageJson.dependencies?.['@nestjs/core'] || packageJson.devDependencies?.['@nestjs/core'];
      const isExpress = packageJson.dependencies?.express || packageJson.devDependencies?.express;
      const projectType = isNestJS ? 'NestJS' : isExpress ? 'Express' : 'Generic';
      
      console.log(`üì¶ Detected project type: ${projectType}`);
      
      // 1. Create default configuration file
      const configPath = path.join(process.cwd(), 'jest-swag.config.json');
      if (!fs.existsSync(configPath) || options.force) {
        const defaultConfig = {
          title: packageJson.name || 'API Documentation',
          version: packageJson.version || '1.0.0',
          description: packageJson.description || 'API Documentation generated by jest-swag',
          outputPath: './docs/openapi.json',
          servers: [
            {
              url: 'http://localhost:3000',
              description: 'Development server'
            }
          ],
          environments: {
            development: {
              servers: [{ url: 'http://localhost:3000', description: 'Development server' }]
            },
            staging: {
              servers: [{ url: 'https://staging.example.com', description: 'Staging server' }]
            },
            production: {
              servers: [{ url: 'https://api.example.com', description: 'Production server' }]
            }
          }
        };
        
        fs.writeFileSync(configPath, JSON.stringify(defaultConfig, null, 2));
        console.log('‚úÖ Created jest-swag.config.json');
      } else {
        console.log('‚è≠Ô∏è  jest-swag.config.json already exists (use --force to overwrite)');
      }
      
      // 2. Update jest.config.js or create one
      const jestConfigPath = path.join(process.cwd(), 'jest.config.js');
      const jestConfigTsPath = path.join(process.cwd(), 'jest.config.ts');
      const hasJestConfig = fs.existsSync(jestConfigPath) || fs.existsSync(jestConfigTsPath);
      
      if (hasJestConfig) {
        console.log('üìù Please add the following to your Jest configuration:');
        console.log(`
  reporters: [
    'default',
    '@foryourdev/jest-swag/dist/reporter'
  ]
        `);
      } else {
        // Create basic jest.config.js
        const jestConfig = `module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/*.test.ts', '**/*.spec.ts'],
  reporters: [
    'default',
    '@foryourdev/jest-swag/dist/reporter'
  ]
};`;
        fs.writeFileSync(jestConfigPath, jestConfig);
        console.log('‚úÖ Created jest.config.js with jest-swag reporter');
      }
      
      // 3. Add npm scripts to package.json
      let modified = false;
      
      if (!packageJson.scripts) {
        packageJson.scripts = {};
      }
      
      if (!packageJson.scripts['test:docs']) {
        packageJson.scripts['test:docs'] = 'jest --reporters=@foryourdev/jest-swag/dist/reporter';
        modified = true;
      }
      
      if (!packageJson.scripts['docs:generate']) {
        packageJson.scripts['docs:generate'] = 'jest-swag generate';
        modified = true;
      }
      
      if (!packageJson.scripts['docs:serve']) {
        packageJson.scripts['docs:serve'] = 'jest-swag serve';
        modified = true;
      }
      
      if (modified) {
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
        console.log('‚úÖ Added npm scripts to package.json');
      }
      
      // 4. Create example test file if requested
      if (options.example) {
        const testDir = path.join(process.cwd(), 'test');
        if (!fs.existsSync(testDir)) {
          fs.mkdirSync(testDir, { recursive: true });
        }
        
        const exampleTestPath = path.join(testDir, 'example.api.test.ts');
        if (!fs.existsSync(exampleTestPath) || options.force) {
          const exampleTest = `import { path, get, post, response, parameter, requestBody } from '@foryourdev/jest-swag';
import request from 'supertest';
import app from '../src/app'; // Adjust to your app path

path('/api/users', () => {
  get('Get all users', () => {
    parameter({
      name: 'limit',
      in: 'query',
      schema: { type: 'integer', default: 10 },
      description: 'Maximum number of users to return'
    });
    
    response(200, 'Successful response', () => {
      return request(app)
        .get('/api/users')
        .expect(200);
    });
  });
  
  post('Create a new user', () => {
    requestBody({
      required: true,
      content: {
        'application/json': {
          schema: {
            type: 'object',
            required: ['name', 'email'],
            properties: {
              name: { type: 'string' },
              email: { type: 'string', format: 'email' }
            }
          }
        }
      }
    });
    
    response(201, 'User created', () => {
      return request(app)
        .post('/api/users')
        .send({ name: 'John Doe', email: 'john@example.com' })
        .expect(201);
    });
  });
});`;
          
          fs.writeFileSync(exampleTestPath, exampleTest);
          console.log('‚úÖ Created example test file at test/example.api.test.ts');
        }
      }
      
      // 5. Installation instructions
      console.log('\n‚ú® Setup complete! Next steps:');
      console.log('1. Review and customize jest-swag.config.json');
      console.log('2. Write your API tests using jest-swag DSL');
      console.log('3. Run: npm run test:docs');
      console.log('4. View docs: npm run docs:serve\n');
      
      if (!packageJson.dependencies?.['@foryourdev/jest-swag'] && !packageJson.devDependencies?.['@foryourdev/jest-swag']) {
        console.log('üì¶ Don\'t forget to install jest-swag:');
        console.log('   npm install --save-dev @foryourdev/jest-swag\n');
      }
      
    } catch (error) {
      console.error('‚ùå Error during initialization:', error);
      process.exit(1);
    }
  });

program
  .command('watch')
  .description('Watch for test changes and regenerate documentation')
  .option('-p, --port <port>', 'Port number for Swagger UI', '3001')
  .option('-c, --config <path>', 'Configuration file path')
  .option('-e, --env <environment>', 'Environment (development, staging, production)')
  .action(async (options) => {
    try {
      const fs = require('fs');
      const path = require('path');
      const chokidar = require('chokidar');
      const { exec } = require('child_process');
      const express = require('express');
      
      console.log('üîç Starting watch mode...\n');
      
      // Load configuration
      const config = await configLoader.loadConfig();
      
      // Set environment if specified
      if (options.env) {
        process.env.NODE_ENV = options.env;
        console.log(`üì¶ Using environment: ${options.env}`);
      }
      
      // Start Swagger UI server
      const app = express();
      const port = parseInt(options.port);
      const docsDir = path.resolve(config.outputPath ? path.dirname(config.outputPath) : './docs');
      
      // Serve static files
      app.use(express.static(docsDir));
      
      // Serve OpenAPI JSON
      app.get('/openapi.json', (req: any, res: any) => {
        const jsonPath = path.join(docsDir, 'openapi.json');
        if (fs.existsSync(jsonPath)) {
          res.sendFile(jsonPath);
        } else {
          res.status(404).json({ error: 'OpenAPI document not found' });
        }
      });
      
      // Swagger UI with live reload
      app.get('/', (req: any, res: any) => {
        const swaggerUiPath = require.resolve('swagger-ui-dist/index.html');
        const swaggerUiDir = path.dirname(swaggerUiPath);
        
        // Custom HTML with auto-reload
        const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>${config.title || 'API Documentation'}</title>
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/swagger-ui-dist/swagger-ui.css">
  <style>
    body { margin: 0; padding: 0; }
    #swagger-ui { display: block; }
    .reload-banner {
      background: #4CAF50;
      color: white;
      padding: 10px;
      text-align: center;
      display: none;
    }
  </style>
</head>
<body>
  <div id="reload-banner" class="reload-banner">Documentation updated! Reloading...</div>
  <div id="swagger-ui"></div>
  <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist/swagger-ui-bundle.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist/swagger-ui-standalone-preset.js"></script>
  <script>
    let lastModified = null;
    
    function loadSwagger() {
      window.ui = SwaggerUIBundle({
        url: '/openapi.json',
        dom_id: '#swagger-ui',
        deepLinking: true,
        presets: [
          SwaggerUIBundle.presets.apis,
          SwaggerUIStandalonePreset
        ],
        plugins: [
          SwaggerUIBundle.plugins.DownloadUrl
        ],
        layout: "StandaloneLayout"
      });
    }
    
    // Initial load
    loadSwagger();
    
    // Poll for changes
    setInterval(async () => {
      try {
        const response = await fetch('/openapi.json', { method: 'HEAD' });
        const modified = response.headers.get('last-modified');
        
        if (lastModified && modified && lastModified !== modified) {
          document.getElementById('reload-banner').style.display = 'block';
          setTimeout(() => {
            location.reload();
          }, 1000);
        }
        lastModified = modified;
      } catch (error) {
        console.error('Error checking for updates:', error);
      }
    }, 2000); // Check every 2 seconds
  </script>
</body>
</html>
        `;
        
        res.send(html);
      });
      
      app.listen(port, () => {
        console.log(`üìö Swagger UI running at http://localhost:${port}`);
      });
      
      // Function to run tests and generate docs
      const regenerateDocs = () => {
        console.log('üîÑ Running tests and regenerating documentation...');
        
        exec('npm run test:docs', (error: any, stdout: string, stderr: string) => {
          if (error) {
            console.error('‚ùå Test failed:', error.message);
            return;
          }
          
          console.log('‚úÖ Documentation regenerated successfully');
          
          // Also generate YAML if needed
          const yamlPath = config.outputPath?.replace('.json', '.yaml');
          if (yamlPath) {
            try {
              const yaml = require('js-yaml');
              const jsonPath = path.resolve(config.outputPath!);
              if (fs.existsSync(jsonPath)) {
                const json = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
                fs.writeFileSync(yamlPath, yaml.dump(json));
              }
            } catch (e) {
              // YAML generation is optional
            }
          }
        });
      };
      
      // Watch test files
      const testPatterns = [
        '**/*.test.ts',
        '**/*.test.js',
        '**/*.spec.ts',
        '**/*.spec.js',
        '**/test/**/*.ts',
        '**/test/**/*.js',
        '**/tests/**/*.ts',
        '**/tests/**/*.js',
      ];
      
      const watcher = chokidar.watch(testPatterns, {
        ignored: [
          '**/node_modules/**',
          '**/dist/**',
          '**/build/**',
          '**/.git/**',
        ],
        persistent: true,
        ignoreInitial: true,
      });
      
      // Watch config file for changes
      const configWatcher = configLoader.watchConfig(async (newConfig) => {
        console.log('üìù Configuration changed, reloading...');
        regenerateDocs();
      });
      
      watcher
        .on('add', (path: string) => {
          console.log(`üìÑ Test file added: ${path}`);
          regenerateDocs();
        })
        .on('change', (path: string) => {
          console.log(`üìù Test file changed: ${path}`);
          regenerateDocs();
        })
        .on('unlink', (path: string) => {
          console.log(`üóëÔ∏è  Test file removed: ${path}`);
          regenerateDocs();
        });
      
      // Initial generation
      regenerateDocs();
      
      console.log('üëÄ Watching for test file changes...');
      console.log('Press Ctrl+C to stop\n');
      
      // Handle cleanup
      process.on('SIGINT', () => {
        console.log('\nüëã Stopping watch mode...');
        watcher.close();
        if (configWatcher) configWatcher.close();
        process.exit(0);
      });
      
    } catch (error) {
      console.error('‚ùå Error in watch mode:', error);
      process.exit(1);
    }
  });

program
  .command('serve')
  .description('Serve the generated documentation')
  .option('-p, --port <port>', 'Port number', '3001')
  .option('-d, --docs <path>', 'Documentation directory', './docs')
  .action(async (options) => {
    try {
      const express = require('express');
      const path = require('path');

      const app = express();
      const port = parseInt(options.port);
      const docsDir = path.resolve(options.docs);

      // Serve static files from docs directory
      app.use(express.static(docsDir));

      // Serve OpenAPI JSON at /openapi.json
      app.get('/openapi.json', (req: any, res: any) => {
        const jsonPath = path.join(docsDir, 'openapi.json');
        if (fs.existsSync(jsonPath)) {
          res.sendFile(jsonPath);
        } else {
          res.status(404).json({ error: 'OpenAPI document not found' });
        }
      });

      // Default route serves index.html
      app.get('/', (req: any, res: any) => {
        const indexPath = path.join(docsDir, 'index.html');
        if (fs.existsSync(indexPath)) {
          res.sendFile(indexPath);
        } else {
          res.send(`
            <h1>jest-swag Documentation Server</h1>
            <p>Documentation not found. Generate it first:</p>
            <pre>npx jest-swag generate</pre>
          `);
        }
      });

      app.listen(port, () => {});
    } catch (error) {
      process.exit(1);
    }
  });

// Helper function to collect multiple values
function collect(value: string, previous: string[]) {
  return previous.concat([value]);
}

// Generate unique temp file path (same logic as utils)
function getTempSpecsFilePath(): string {
  const tempDir = os.tmpdir();
  const projectHash = Math.abs(hashCode(process.cwd())).toString(36);
  const processId = process.pid;
  return path.join(tempDir, `jest-swag-specs-${projectHash}-${processId}.json`);
}

// Simple hash function for project path
function hashCode(str: string): number {
  let hash = 0;
  if (str.length === 0) return hash;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}

// Helper function to clean up temporary spec file
function cleanupTempFile(filePath: string): void {
  try {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
  } catch (error) {
    // Ignore errors when cleaning up
  }
}

program.parse();
