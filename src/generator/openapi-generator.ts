/**
 * OpenAPI document generator
 */

import * as fs from 'fs';
import * as path from 'path';
import { ApiSpec, apiSpecs } from '../utils';

export interface OpenAPIDocument {
  openapi: string;
  info: {
    title: string;
    version: string;
    description?: string;
  };
  servers?: Array<{
    url: string;
    description?: string;
  }>;
  paths: { [path: string]: PathItem };
  components?: {
    schemas?: { [schemaName: string]: any };
    securitySchemes?: { [schemeName: string]: any };
  };
  security?: Array<{ [schemeName: string]: string[] }>;
}

interface PathItem {
  [method: string]: Operation;
}

interface Operation {
  summary?: string;
  description?: string;
  tags?: string[];
  parameters?: any[];
  requestBody?: any;
  responses: { [statusCode: string]: any };
  security?: Array<{ [schemeName: string]: string[] }>;
}

export class OpenAPIGenerator {
  private config: {
    title: string;
    version: string;
    description?: string;
    servers?: Array<{ url: string; description?: string }>;
    outputPath?: string;
  };

  constructor(config: {
    title: string;
    version: string;
    description?: string;
    servers?: Array<{ url: string; description?: string }>;
    outputPath?: string;
  }) {
    this.config = {
      outputPath: './docs/openapi.json',
      ...config,
    };
  }

  /**
   * Generates OpenAPI document from collected API specs
   */
  public generateDocument(): OpenAPIDocument {
    const document: OpenAPIDocument = {
      openapi: '3.0.3',
      info: {
        title: this.config.title,
        version: this.config.version,
        description: this.config.description,
      },
      paths: {},
    };

    if (this.config.servers) {
      document.servers = this.config.servers;
    }

    // Group specs by path and method
    const pathGroups: { [path: string]: { [method: string]: ApiSpec } } = {};

    apiSpecs.forEach((spec) => {
      if (!pathGroups[spec.path]) {
        pathGroups[spec.path] = {};
      }
      pathGroups[spec.path][spec.method] = spec;
    });

    // Convert to OpenAPI format
    Object.entries(pathGroups).forEach(([pathName, methods]) => {
      const pathItem: PathItem = {};

      Object.entries(methods).forEach(([method, spec]) => {
        const operation: Operation = {
          summary: spec.summary,
          description: spec.description,
          tags: spec.tags,
          parameters: spec.parameters,
          responses: spec.responses || { '200': { description: 'Success' } },
        };

        if (spec.requestBody) {
          operation.requestBody = spec.requestBody;
        }

        if (spec.security) {
          operation.security = spec.security;
        }

        pathItem[method] = operation;
      });

      document.paths[pathName] = pathItem;
    });

    return document;
  }

  /**
   * Writes the OpenAPI document to file
   */
  public async writeDocument(document?: OpenAPIDocument): Promise<void> {
    const doc = document || this.generateDocument();
    const outputPath = path.resolve(this.config.outputPath!);
    const outputDir = path.dirname(outputPath);

    // Ensure output directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write JSON file
    fs.writeFileSync(outputPath, JSON.stringify(doc, null, 2));

    console.log(`OpenAPI document generated: ${outputPath}`);
  }

  /**
   * Generates and writes OpenAPI document
   */
  public async generate(): Promise<OpenAPIDocument> {
    const document = this.generateDocument();
    await this.writeDocument(document);
    return document;
  }
}

// Default instance for convenience
export const defaultGenerator = new OpenAPIGenerator({
  title: 'API Documentation',
  version: '1.0.0',
  description: 'Generated by jest-swag',
  servers: [
    {
      url: 'http://localhost:3000',
      description: 'Development server',
    },
  ],
});
